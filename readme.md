## TS 协变和逆变

## 如何理解面向对象和函数式编程

### 函数式编程

特点：

- 函数是一等公民：函数也是一种类型，可以被传入也可以被传出。
- 声明式编程： 代码可读性强，不需要关注函数逻辑，写完了业务的逻辑，在完成每一步对应的函数
- 纯函数
  1. 引用透明（纯输入纯输出）（输出值仅由输入值影响）
  2. 数据不可变 （传入的引用类型的参数不能被改变，改变了就是篡改了外部的状态）如果要更新，可以 return 出去然后在外部赋值。
  3. 没有副作用（比如说我在面向对象的时候需要在方法中修改 this 下的状态，这样会导致看不见的地方的数据被改变，会带来意料之外的错误

### 面向对象

- 封装
  每一个实例化的对象的修改实际上都是对一组状态的封装

- 继承
  把相似逻辑写成模板，用父子关系不断构建类似于现实物体的逻辑。

- 多态
  对不不同的地方使用多态（重载和覆盖）的方法完成具体的修改。

### 共同点

两者都好处:都有利于高效率的开发，更容易维护

坏处：函数式占空间大，因为默认数据不可变，如果要在处理过程发生变化需要复制空间这样
面向对象容易简单逻辑复杂化，

### 不同点

函数式对多线程处理比较方便，因为默认数据不可变也就省掉了很多的互斥锁。而面向对象由于状态的共享会导致多线程操控不对象共享的状态。容易死锁

## JS 的基本类型？数字是对象吗？

在 JavaScript 中，基本数据类型有七种：null、undefined、boolean、number、string、symbol 和 bigint。

其中，前六种基本数据类型不是对象，它们是原始值，它们没有属性和方法。虽然 JavaScript 中的基本数据类型不是对象，但是 JavaScript 引擎会自动将其转换为对象，从而可以让我们调用一些方法。

例如，我们可以在字符串上调用 toUpperCase() 方法，虽然字符串是基本数据类型，但是 JavaScript 引擎会自动将其转换为 String 对象，以便我们调用该方法。

至于第七种基本数据类型 bigint，它是在 ECMAScript 2020 中新增的。它是一种用来表示大整数的数据类型，它也不是对象，但是它可以使用一些基本的方法，例如 toString() 和 valueOf()。

## Vue3 如何实现双向绑定，Vue2 的区别

Vue2:
Vue2 实现双向绑定的原理是通过数据劫持（Data Observation）来实现的。

在 Vue2 中，通过使用 Object.defineProperty 方法来劫持组件的 data 对象中的属性，从而实现对属性的访问控制，当数据变化时，通过调用 Watcher 对象的 update 方法来通知对应的视图进行更新。而在模板中使用 v-model 指令时，Vue2 会将表单元素的 value 绑定到组件 data 对象中的对应属性上，并通过监听表单元素的 input 或 change 事件来实现视图到数据的绑定.

具体来说，当表单元素的值发生变化时，会触发对应的 input 或 change 事件，然后 Vue2 会通过绑定的 setter 方法将新的值赋给对应的 data 属性，此时又会触发数据劫持中的 setter 方法，从而通过 Watcher 对象将数据变化通知给视图进行更新。

## 如何理解 JS 的异步 async await

## 如何理解 Python 里的 async await

## 是否做过页面网站，使用的布局方式（说的 flex）

## 接触过 svelte 吗，有什么特点啥的

## Golang 的协程（答的是管道，不很清楚，有句话概念不会）

## 如何理解泛型,TS 中的泛型与 Golang 中新加入的泛型

## 说一下常见的数据结构

线性：

- 线性表
- 链表
- 队列
  - 优先队列
  - 单调队列
- 栈
- 堆
  非线性：
- 树：
  - 二叉树
    - 红黑树
    - B+树
    - BST
    - AVL
  - 多叉树

## git fetch & git pull

fetch 只是下载远程的更改到本地的仓库，而 git pull 是将远程代码直接拉取并合并到目前的这个更改的分支上。

## Virtual DOM 与 diff 算法

Diff 算法是一种对比算法。对比两者是旧虚拟 DOM 和新虚拟 DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实 DOM，进而提高效率。
使用虚拟 DOM 算法的损耗计算：
总损耗 = 虚拟 DOM 增删改+（与 Diff 算法效率有关）真实 DOM 差异增删改+（较少的节点）排版与重绘
直接操作真实 DOM 的损耗计算：
总损耗 = 真实 DOM 完全增删改+（可能较多的节点）排版与重绘

### Diff 算法的原理

当数据改变时，会触发 setter，并且通过 Dep.notify 去通知所有订阅者 Watcher，订阅者们就会调用 patch 方法，给真实 DOM 打补丁，更新相应的视图。

## 多语言项目的开发经验

多语言适配（i18n）与使用哪种前端框架无关。

本质上是维护一个 map，然后通过一个中间层返回当前语种的显示内容。

这个 map 可以存储在 DB，通过 HTTP 接口获取；
也可以硬编码在 javascript 文件中，通过某个公共的 translate 方法获取；

当前语种可以由用户选择存储在本地；
也可以由 WebServer 通过判断客户端 IP 地址来识别使用哪种语种；

## JS 内部的 sort 使用的是什么算法

插入排序和快速排序相结合

## 懒加载和预加载

懒加载是指在页面滚动时，按需加载图片或其他资源，而不是在页面加载时就一次性加载全部资源。这种技术可以减少页面的初始加载时间，提高网页的响应速度。懒加载可以用于图片、视频、音频等大型资源的加载，或者用于网站中需要滚动加载的内容。

预加载是指在页面加载时，提前加载一些可能需要用到的资源，以便在需要时能够立即显示。这些资源包括图片、CSS 文件、JavaScript 文件、字体文件等。预加载可以缩短资源的加载时间，提高网页的响应速度，增强用户体验。
